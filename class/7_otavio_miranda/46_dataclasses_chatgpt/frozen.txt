ğŸ”’ Imutabilidade com frozen=True no dataclass

Quando vocÃª usa @dataclass(frozen=True), os objetos criados nÃ£o podem ser modificados apÃ³s serem instanciados â€” eles se tornam quase como tuplas nomeadas.

Isso Ã© Ãºtil quando vocÃª quer garantir que os dados nÃ£o mudem depois de criados, ajudando a evitar bugs em sistemas que dependem de consistÃªncia (por exemplo, em configuraÃ§Ã£o, cache, ou chaves de dicionÃ¡rio).

ğŸ“Œ Exemplo bÃ¡sico de frozen=True
from dataclasses import dataclass

@dataclass(frozen=True)
class Config:
    host: str
    port: int

c = Config("localhost", 8080)
print(c.host)  # localhost

# Tentando alterar um atributo:
c.port = 9090  # âŒ Erro! dataclasses.FrozenInstanceError


SaÃ­da do erro:

dataclasses.FrozenInstanceError: cannot assign to field 'port'


âœ… Isso garante que Config Ã© imutÃ¡vel.

ğŸ“Œ Objetos frozen sÃ£o hashable

Objetos imutÃ¡veis podem ser usados como chaves de dicionÃ¡rio ou adicionados a sets:

c1 = Config("localhost", 8080)
c2 = Config("localhost", 8080)

print(c1 == c2)  # True
d = {c1: "Servidor A"}
print(d[c2])     # Servidor A (funciona porque sÃ£o hashable)

âš ï¸ AtenÃ§Ã£o: Imutabilidade nÃ£o Ã© recursiva!

Se vocÃª tiver um atributo mutÃ¡vel (lista, dict, set), ele ainda poderÃ¡ ser alterado, mesmo em uma dataclass frozen.

from dataclasses import dataclass, field

@dataclass(frozen=True)
class Team:
    name: str
    members: list = field(default_factory=list)

t = Team("Pythonistas")
t.members.append("Luan")  # âœ… Isso funciona! Lista continua mutÃ¡vel
print(t.members)  # ['Luan']


Se vocÃª realmente quer imutabilidade total, use tuplas em vez de listas:

@dataclass(frozen=True)
class Team:
    name: str
    members: tuple = field(default_factory=tuple)

t = Team("Pythonistas", members=("Luan",))
# t.members += ("Maria",)  # âŒ Erro! Tupla Ã© imutÃ¡vel

ğŸ“Œ frozen e __post_init__

Quando usamos frozen=True, nÃ£o podemos modificar atributos dentro do __post_init__ da forma tradicional.
Mas hÃ¡ uma soluÃ§Ã£o: usar object.__setattr__, que bypassa a imutabilidade durante a inicializaÃ§Ã£o.

Exemplo:

@dataclass(frozen=True)
class Order:
    product: str
    quantity: int
    total: float = 0.0

    def __post_init__(self):
        object.__setattr__(self, "total", self.quantity * 10.0)

o = Order("Caneta", 3)
print(o.total)  # 30.0

âœ… Quando usar frozen=True

ConfiguraÃ§Ãµes que nÃ£o devem ser alteradas.

Objetos que precisam ser usados como chaves de dicionÃ¡rio.

Objetos que precisam ser thread-safe (imutabilidade evita condiÃ§Ãµes de corrida).

Modelos de dados que vocÃª quer tratar como "valores" (Value Objects em DDD).